# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'se1.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os
import pandas as pd
import tensorflow as tf
import numpy as np
import pickle
#Import the modules
import text2emotion as te
from textblob import TextBlob

from googletrans import Translator
translator = Translator()

def translatetoEng(text):
    out = translator.translate(text, dest = "en")
    #print(out.text)
    out = out.text
    return out

import requests
import pickle
from datetime import datetime

import re
import time

def inner_regex(s):
    return re.sub(r'<[^>]*>', '', s)

def inner_regex_compiled(s,r):
    return r.sub('', s)

def inner_substr(s):
    s_ind = s.find('>') + 1
    e_ind = s.find('<', s_ind)
    return s[s_ind:e_ind]


s = '<stuff to remove> get this stuff <stuff to remove>'

s3 = inner_substr(s)
print(s3)

URL = "https://nhentai.net/search/?q=language%3Aenglish&page=2"
fbid = 1095733974399434
page = requests.get(URL)

f = open("scraped.txt", "w")
f.write(page.text)
f.close()

str1 = page.text

users = []
comments = []

def findAllOccurence(string, substr):
    # defining substring
    str1 = string
    #print(string)
    print(substr)
    # printing original string 
    #print("The original string is : " + str1)
      
    # printing substring 
    #print("The substring to find : " + substr)
      
    # using list comprehension + startswith()
    # All occurrences of substring in string 
    res = [i for i in range(len(str1)) if str1.startswith(substr, i)]
    print("occurence", res)
    # printing result 
    #print("The start indices of the substrings are : " + str(res))
    return res
    #return [str1[res[i]:res[i]+len(substr)] for i in range(len(res))]

def findComments(str1):
    substr = "<div class=\"_14ye\">"
    end = len(substr)
    res = findAllOccurence(str1, substr)
    print(res)
    if(len(res) != 0):
        return [str1[res[i] + end:str1.find("</div><div class=\"mUFICommentContent\">", res[i] + 20)] for i in range(len(res))]
    else:
        substr = "<div class=\"cv\">"
        end = len(substr)
        res = findAllOccurence(str1, substr)
        print(res)
        return [str1[res[i] + end:str1.find("</div><div class=\"cw\">", res[i] + 15)] for i in range(len(res))]
def findUsers(str1):
    substr = "<a class=\"_1s79 _52jh\">"
    end = len(substr)
    res = findAllOccurence(str1, substr)
    print(res)
    return [str1[res[i] + end:str1.find("</a></h3>", res[i] + 19)] for i in range(len(res))]
    
    """
    substr = "<div class=\"_14ye\">"
    end = len(substr)
    res = findAllOccurence(str1, substr)
    print(res)
    return [str1[res[i] + end:str1.find("</div><div class=\"mUFICommentContent\">", res[i] + 20)] for i in range(len(res))]
    """
def getPreviousLink(str1):
    substr = '<div class="_55wr async_elem" id="see_prev_'# + str(fbid) + '">'
    
    print(str1)
    end = len(substr)
    res = findAllOccurence(str1, substr)
    res = [str1.find("href=\"", res[0])]
    print("res", res)
    #astr = [str1[res[i] + end:str1.find("<img", res[i] + 19)] for i in range(len(res))]
    astr = str1[res[0]:str1.find("\">")]
    astr = "https://mbasic.facebook.com" + astr
    print(astr)
    return astr
    
def getNextLink(str1, currURL):
    substr = '<div class="_55wr async_elem" id="see_next_'# + str(fbid) + '">'
    end = len(substr)
    res = findAllOccurence(str1, substr)
    res = [str1.find("href=\"", res[0])]
    print("res", res)
    #astr = [str1[res[i] + end:str1.find("<img", res[i] + 19)] for i in range(len(res))]
    astr = str1[res[0]:str1.find("\">")]
    astr = "https://mbasic.facebook.com" + astr
    print(astr)
    return astr
#print(findAllOccurence(str1, "<div class=\"_14ye\">"))
count = 1
MainURL = URL
pagecount = 0
isPrev = True

def searchprev(URL, once):
    page = requests.get(URL)
    """
    f = open("scraped.txt", "w")
    f.write(page.text)
    f.close()
    """
    q = True
    try:
        print("Scraping", URL)
        str1 = page.text
        #print(str1)
        prevlink = getPreviousLink(str1)
        prevlink = prevlink.replace("&amp;", "&")
        print(prevlink)
        
        global users
        global currcomments
        global comments
        
        try:
            if(once):
                users += findUsers(str1)
                currcomments = findComments(str1)
                comments += currcomments
                print("comlen", len(currcomments))
        except Exception as e:
            a=0
            print(e)
    except:
        q = False
    if q:
        searchprev(prevlink, True)
        
def searchnext(URL, once):
    page = requests.get(URL)
    
    """
    f = open("scraped.txt", "w")
    f.write(page.text)
    f.close()
    """
    q = True
    try:
        print("Scraping", URL)
        str1 = page.text
        #print(str1)
        prevlink = getNextLink(str1)
        prevlink = prevlink.replace("&amp;", "&")
        print(prevlink)
        
        global users
        global currcomments
        global comments
        
        try:
            if(once):
                users += findUsers(str1)
                currcomments = findComments(str1)
                comments += currcomments
                print("comlen", len(currcomments))
        except Exception as e:
            a=0
            print(e)
    except:
        q = False
    if q:
        searchnext(prevlink, True)

def searchcom(URL):
    global users
    global currcomments
    global comments
    try:
        page = requests.get(URL)
        mainURL = URL
        """
        f = open("scraped.txt", "w")
        f.write(page.text)
        f.close()
        """
        q = True
        try:
            pagenum = 0
            stillGoing = True
            while stillGoing:
                page = requests.get(mainURL + "&p=" + str(pagenum))
                print("Scraping", URL)
                str1 = page.text
                
                try:
                    print("Scraping Comments... ")
                    users += findUsers(str1)
                    currcomments = findComments(str1)
                    comments += currcomments
                    print("comlen", len(currcomments))
                    if len(currcomments) == 0:
                        stillGoing = False
                    if pagenum == 110:
                        stillGoing = False
                    pagenum += 10
                except Exception as e:
                    a=0
                    print(e)
                    
        except Exception as e:
            print(e)
            q = False
        
        try:
            searchnext(URL, False, 0)
        except:
            pass
        try:
            searchprev(URL, False, 0)
        except:
            pass

        print(comments)
        print("Hello?")
    except Exception as e:
        print(e)
        print("Invalid URL")
    

df = pd.read_csv(os.path.join('jigsaw-toxic-comment-classification-challenge','train2.csv', 'train2.csv'))
df.head()

from tensorflow.keras.layers import TextVectorization

X = df['comment_text']
y = df[df.columns[2:]].values

MAX_FEATURES = 200000 # number of words in the vocab

vectorizer = TextVectorization(max_tokens=MAX_FEATURES,
                               output_sequence_length=1800,
                               output_mode='int')
							   
vectorizer.adapt(X.values)
vectorized_text = vectorizer(X.values)

#MCSHBAP - map, chache, shuffle, batch, prefetch  from_tensor_slices, list_file
dataset = tf.data.Dataset.from_tensor_slices((vectorized_text, y))
dataset = dataset.cache()
dataset = dataset.shuffle(160000)
dataset = dataset.batch(16)
dataset = dataset.prefetch(8) # helps bottlenecks

train = dataset.take(int(len(dataset)*.7))
val = dataset.skip(int(len(dataset)*.7)).take(int(len(dataset)*.2))
test = dataset.skip(int(len(dataset)*.9)).take(int(len(dataset)*.1))

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dropout, Bidirectional, Dense, Embedding

model = Sequential()
# Create the embedding layer 
model.add(Embedding(MAX_FEATURES+1, 32))
# Bidirectional LSTM Layer
model.add(Bidirectional(LSTM(32, activation='tanh')))
# Feature extractor Fully connected layers
model.add(Dense(128, activation='relu'))
model.add(Dense(256, activation='relu'))
model.add(Dense(128, activation='relu'))
# Final layer 
model.add(Dense(5, activation='sigmoid'))

model.compile(loss='BinaryCrossentropy', optimizer='Adam')

model.summary()
filename = 'model/sad.h5'
history = None
try:
    #history = pickle.load(open(filename, 'rb'))
    #result = loaded_model.score(X_test, Y_test)
    print("Loading model")
    history = tf.keras.models.load_model(filename )
    #result = history.score(X_test, Y_test)
    print("Loaded Model")
except Exception as e:
    print(e)
    history = model.fit(train, epochs=10, validation_data=val)
    #pickle.dump(history, open(filename, 'wb'))
    model.save(filename)

from matplotlib import pyplot as plt
"""
print(history.history)
plt.figure(figsize=(8,5))
pd.DataFrame(history.history).plot()
plt.show()
"""
#batch = test.as_numpy_iterator().next()


#batch_X, batch_y = test.as_numpy_iterator().next()
#print((model.predict(batch_y) > 0.5).astype(int))

#print((model.predict(batch_X) > 0.5).astype(int))
"""

text = 'Glad I\'m an old fuck and don\'t have to meet a ton of theists in my day-to-day activities. Because this would be a "Nope...you\'re a fucking idiot and I''m walking away" conversations...'
text = translatetoEng(text)
input_text = vectorizer(text)

print(text)
df.columns[2:]

res = history.predict(np.expand_dims(input_text, 0))
print((res > 0.5).astype(int))
emotion = te.get_emotion(text)
blob = TextBlob(text)
sentiment = blob.sentiment.polarity # -1 to 1
print(sentiment)
print(emotion)
print(res)
print("Nexts")

text = 'I\'m fine, thank you'
text = translatetoEng(text)
input_text = vectorizer(text)

print(text)
df.columns[2:]

res = history.predict(np.expand_dims(input_text, 0))
print((res > 0.5).astype(int))
emotion = te.get_emotion(text)
blob = TextBlob(text)
sentiment = blob.sentiment.polarity # -1 to 1
print(sentiment)
print(emotion)
print(res)
"""

from PyQt5 import QtCore, QtGui, QtWidgets
class TextEdit(QtWidgets.QTextEdit):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.textChanged.connect(self.updateGeometry)

    def sizeHint(self):
        hint = super().sizeHint()
        if self.toPlainText():
            doc = self.document().clone()
            width = self.width() - self.frameWidth() * 2
            if self.verticalScrollBar().isVisible():
                width -= self.verticalScrollBar().width()
            doc.setTextWidth(width)
            height = round(doc.size().height())
        else:
            height = self.fontMetrics().height()
            height += self.document().documentMargin() * 2
        height += self.frameWidth() * 2
        hint.setHeight(height)
        return hint


class Ui_MainWindow(object):
    col, row = 3, 5
    headersMain = ["Number", "Date Created", "Source", "Reply From", "Original Language", "Author", "Text", "Translated", "Polarity", "Happy", "Angry", "Surprise", "Sad", "Fear", "Toxic", "Severe Toxic", "Obscene", "Threat", "Insult", "Identity Hate"]
    LANGUAGES = {
        'af': 'afrikaans',
        'sq': 'albanian',
        'am': 'amharic',
        'ar': 'arabic',
        'hy': 'armenian',
        'az': 'azerbaijani',
        'eu': 'basque',
        'be': 'belarusian',
        'bn': 'bengali',
        'bs': 'bosnian',
        'bg': 'bulgarian',
        'ca': 'catalan',
        'ceb': 'cebuano',
        'ny': 'chichewa',
        'zh-cn': 'chinese (simplified)','zh-tw': 'chinese (traditional)','co': 'corsican',
        'hr': 'croatian',
        'cs': 'czech',
        'da': 'danish',
        'nl': 'dutch',
        'en': 'english',
        'eo': 'esperanto',
        'et': 'estonian',
        'tl': 'filipino',
        'fi': 'finnish',
        'fr': 'french',
        'fy': 'frisian',
        'gl': 'galician',
        'ka': 'georgian',
        'de': 'german',
        'el': 'greek',
        'gu': 'gujarati',
        'ht': 'haitian creole',
        'ha': 'hausa',
        'haw': 'hawaiian',
        'iw': 'hebrew',
        'he': 'hebrew',
        'hi': 'hindi',
        'hmn': 'hmong',
        'hu': 'hungarian',
        'is': 'icelandic',
        'ig': 'igbo',
        'id': 'indonesian',
        'ga': 'irish',
        'it': 'italian',
        'ja': 'japanese',
        'jw': 'javanese',
        'kn': 'kannada',
        'kk': 'kazakh',
        'km': 'khmer',
        'ko': 'korean',
        'ku': 'kurdish (kurmanji)','ky': 'kyrgyz',
        'lo': 'lao',
        'la': 'latin',
        'lv': 'latvian',
        'lt': 'lithuanian',
        'lb': 'luxembourgish',
        'mk': 'macedonian',
        'mg': 'malagasy',
        'ms': 'malay',
        'ml': 'malayalam',
        'mt': 'maltese',
        'mi': 'maori',
        'mr': 'marathi',
        'mn': 'mongolian',
        'my': 'myanmar (burmese)','ne': 'nepali',
        'no': 'norwegian',
        'or': 'odia',
        'ps': 'pashto',
        'fa': 'persian',
        'pl': 'polish',
        'pt': 'portuguese',
        'pa': 'punjabi',
        'ro': 'romanian',
        'ru': 'russian',
        'sm': 'samoan',
        'gd': 'scots gaelic',
        'sr': 'serbian',
        'st': 'sesotho',
        'sn': 'shona',
        'sd': 'sindhi',
        'si': 'sinhala',
        'sk': 'slovak',
        'sl': 'slovenian',
        'so': 'somali',
        'es': 'spanish',
        'su': 'sundanese',
        'sw': 'swahili',
        'sv': 'swedish',
        'tg': 'tajik',
        'ta': 'tamil',
        'te': 'telugu',
        'th': 'thai',
        'tr': 'turkish',
        'uk': 'ukrainian',
        'ur': 'urdu',
        'ug': 'uyghur',
        'uz': 'uzbek',
        'vi': 'vietnamese',
        'cy': 'welsh',
        'xh': 'xhosa',
        'yi': 'yiddish',
        'yo': 'yoruba',
        'zu': 'zulu'
    }
    
    currentfilter = []
    currentmainarr = []
    currentnewtext = ""
    
    def searchURL(self):
        global users
        global currcomments
        global comments
        
        users = []
        currcomments = []
        comments = []
        
        global fbid
        URL = self.textEdit_2.toPlainText()
        fbid = URL[URL.find('fbid=') + len('fbid='):URL.find('&')]

        searchcom(URL)
        #print(users)
        #print(comments)

        comment_data = {
            "users" : users,
            "comments" : comments,
        }

        filename = str(datetime.today().strftime('%Y-%m-%d %H-%M-%S')) + "_usercomments"
        commentfile = open(filename, 'wb')
        pickle.dump(comment_data, commentfile)
        commentfile.close()

        commentfile = open(filename, "rb")
        comment_data = pickle.load(commentfile)
        commentfile.close()

        cdlen = len(comment_data["comments"])
        userlen = len(comment_data["users"])
        for i in range(cdlen):
            comment_data["comments"][i] = inner_substr(comment_data["comments"][i])
            if comment_data["comments"][i] == '':
                comment_data["comments"][i] = "None"
        print(userlen, comment_data["users"])
        print(cdlen, comment_data["comments"])
        for i in range(cdlen):
            #print(comment_data["users"][i])
            print(comment_data["comments"][i])
            try:
                self.newText2(URL, comment_data["users"][i], comment_data["comments"][i])
            except Exception as e:
                print(e)
                try:
                    self.newText2(URL, "Anonymous", comment_data["comments"][i])
                except:
                    self.newText2(URL, "Error", "Error")
        
        
        #print(comment_data)

        f = open("users.txt", "w")
        f.write(str(users))
        f.close()

        f = open("comments.txt", "w")
        f.write(str(comments))
        f.close()
    
    def processText(self, text):
        author = "Anonymous"
        ortext = text
        try:
            lang = translator.detect(text).lang
            text = translatetoEng(text)
            translated = text
            input_text = vectorizer(translated)

            print(translated)
            df.columns[2:]

            res = history.predict(np.expand_dims(input_text, 0))
            #print((res > 0.5).astype(int))
            emotion = te.get_emotion(translated)
            blob = TextBlob(translated)
            sentiment = blob.sentiment.polarity # -1 to 1
            
            #print(sentiment)
            #print(emotion)
            #print(res)
            #print(res[0][0])
            try:
                lang = self.LANGUAGES[lang]
            except:
                lang = unknown
            return [lang, author, ortext, translated, sentiment, 
            emotion["Happy"], emotion["Angry"], emotion["Surprise"], emotion["Sad"], emotion["Fear"],
            res[0][0], res[0][1], res[0][2], res[0][3], res[0][4], res[0][5]]
        except Exception as e:
            print(e)
            return "error"
            
    def table_to_list(self, table):
        result = []
        num_rows, num_cols = table.rowCount(), table.columnCount()
        for col in range(num_cols):
            rows = []
            for row in range(num_rows):
                item = table.item(row, col)
                rows.append(item.text() if item else '')
            result.append(rows)
        return result
        
    def filter2(self, filterarr):
        filterarr = self.table_to_list(self.tableWidget)
        headersMainLen = len(self.headersMain)
        headersMain = self.headersMain
        
        self.tableWidget_3.setRowCount(0)
        self.tableWidget_3.setColumnCount(len(headersMain))
        self.tableWidget_3.setHorizontalHeaderLabels(headersMain)
        for i in range(self.tableWidget.rowCount()):
            #print(self.tableWidget.rowCount())
            item = self.tableWidget.item(i, 3)
            if item.checkState():
                #checked_list.append([i,1])
                filterarr[3][i] = True
            else:
                filterarr[3][i] = False
            for j in range(4,6):
                item = self.tableWidget.cellWidget(i, j)
                if item.isChecked():
                    filterarr[j][i] = True
                else:
                    filterarr[j][i] = False
        proplen, tablen = len(self.headersMain), len(filterarr[0])
        for i in range(tablen):
            for j in range(proplen):
                if filterarr[0][i] == self.headersMain[j]:
                    filterarr[0][i] = j
                    break
        print(filterarr)
        
        arr = self.table_to_list(self.tableWidget_2)
        xlen = len(arr)
        ylen = len(arr[0])
        print(xlen)
        print(ylen)
        print(filterarr[1], filterarr[2])
        print(arr)
        
        inclusions = [False] * ylen
        filtered = [[]] * headersMainLen
        filtery = 0
        for y in range(0,ylen):
            currarr = [False] * len(filterarr[0])
            print(y)
            j = 0
            #Match Conditions
            for x in filterarr[0]:
                x = int(x)
                if float(arr[x][y]) >= float(filterarr[1][j]) and float(arr[x][y]) <= float(filterarr[2][j]):
                    print(str(x) + "," + str(y) + "," + str(j) + " TRUE " + str(float(arr[x][y])))
                    currarr[j] = True
                else:
                    print(str(x) + "," + str(y) + "," + str(j) + " FALSE " + str(float(arr[x][y])))
                j += 1
            #Check if included
            currout = True
            j = 0
            currarrlen = len(currarr)
            for k in range(currarrlen):
                currk = currarr[k]
                if filterarr[3][j]:
                    currk = not currk
                if filterarr[4][j]:
                    currout = currk or currout
                else:
                    currout = currk and currout
                if not currout:
                    break
                j += 1
            print(currout)
            #Append to Filtered
            if currout:
                self.tableWidget_3.insertRow(filtery)
                #print(filtery)
                #print()
                #filtered[0].append(None)
                for q in range(headersMainLen):
                    #filtered[q][filtery] = float(arr[q][y])
                    #print(q, y, float(arr[q][y]))
                    item = QtWidgets.QTableWidgetItem(str(arr[q][y]))
                    item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsEditable)
                    """
                    if q in [2, 6, 7]:
                        combo = QtWidgets.QTextEdit(self.tableWidget_2)
                        combo.setText(str(arr[q][y]))
                        self.tableWidget_3.setCellWidget(y, q, combo)
                    
                    else:
                    """
                    self.tableWidget_3.setItem(filtery, q, item)
                    
                    #print(filtered)
                filtery += 1
            #self.showFilters(filtered)
        #Display Filtered
        print(filtered)
        #self.showFilters(filtered)
        horizontalHeader = self.tableWidget_3.horizontalHeader()
        """
        for i in range(len(self.headersMain)):
            horizontalHeader.setSectionResizeMode(
                i, QtWidgets.QHeaderView.ResizeToContents)
        """

    def list_to_table(self, mylist, table, headers):
        table.setRowCount(0)
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        
        col = len(headers)
        row = len(mylist[0])
        for y in range(row):
            table.insertRow(y)
            for x in range(col):
                try:
                    item = QtWidgets.QTableWidgetItem(str(mylist[x][y]))
                except:
                    item = QtWidgets.QTableWidgetItem(str(0))
                item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsEditable)
                table.setItem(y, x, item)
        horizontalHeader = table.horizontalHeader()
        """
        for i in range(len(self.headersMain)):
            horizontalHeader.setSectionResizeMode(
                i, QtWidgets.QHeaderView.ResizeToContents)
        """
    def updateTable2(self):
        headers = self.headersMain
        currentarr = self.currentmainarr
        
        self.list_to_table(currentarr, self.tableWidget_2, headers)
        row = len(currentarr[0])
        """
        for y in range(row):
            combo = QtWidgets.QTextEdit(self.tableWidget_2)
            combo.setText(str(currentarr[6][y]))
            self.tableWidget_2.setCellWidget(y, 6, combo)
            
            combo2 = QtWidgets.QTextEdit(self.tableWidget_2)
            combo2.setText(str(currentarr[7][y]))
            self.tableWidget_2.setCellWidget(y, 7, combo2)
            
            combo3 = QtWidgets.QTextEdit(self.tableWidget_2)
            combo3.setText(str(currentarr[2][y]))
            self.tableWidget_2.setCellWidget(y, 2, combo3)
        """
    def setTable2(self):
        headers = self.headersMain
        currentarr = [
            [0],
        ] * len(headers)

        print(currentarr)
        self.list_to_table(currentarr, self.tableWidget_2, headers)
        self.currentmainarr = currentarr
        
        row = len(currentarr[0])
        """
        for y in range(row):
            combo = QtWidgets.QTextEdit(self.tableWidget_2)
            combo.setText(str(currentarr[6][y]))
            self.tableWidget_2.setCellWidget(y, 6, combo)
            
            combo2 = QtWidgets.QTextEdit(self.tableWidget_2)
            combo2.setText(str(currentarr[7][y]))
            self.tableWidget_2.setCellWidget(y, 7, combo2)
            
            combo3 = QtWidgets.QTextEdit(self.tableWidget_2)
            combo3.setText(str(currentarr[2][y]))
            self.tableWidget_2.setCellWidget(y, 2, combo3)
        """
            
    def setTable1(self):
        headersMain = self.headersMain
        col, row = self.col, self.row
        print(col, row)
        self.tableWidget.setRowCount(0)
        
        headers = ["Properties", "min", "max", "not", "inclusive", "exclusive"]
        self.tableWidget.setColumnCount(len(headers))
        self.tableWidget.setHorizontalHeaderLabels(headers)
        #for x in range(len(headers)):
        #    self.tableWidget.insertColumn(headers[x])
        
        properties = ["Polarity", "Happy", "Angry", "Surprise", "Sad", "Fear", "Toxic", "Severe Toxic", "Obscene", "Threat", "Insult", "Identity Hate"]
        row = len(properties)
        for y in range(row):
            self.tableWidget.insertRow(y)
        for y in range(row):
            item = QtWidgets.QTableWidgetItem(properties[y])
            item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled)
            self.tableWidget.setItem(y, 0, item)
            #self.tableWidget.setCellWidget(y, x, new self.label)
        
        for y in range(row):
            for i in range(0,2):
                item = QtWidgets.QTableWidgetItem("0")
                item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsEditable)
                self.tableWidget.setItem(y, 1+i, item)
            chkBoxItem = QtWidgets.QTableWidgetItem()
            chkBoxItem.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
            chkBoxItem.setCheckState(QtCore.Qt.Unchecked)       
            self.tableWidget.setItem(y,3,chkBoxItem)
            
            button_group = QtWidgets.QButtonGroup(self.tableWidget)                     # <---
            button_group.setExclusive(True)           # <---
            checkbox = QtWidgets.QRadioButton()
            checkbox.setChecked(True)
            button_group.addButton(checkbox)                  # <---
            self.tableWidget.setCellWidget(y, 4, checkbox)

            checkbox = QtWidgets.QRadioButton()
            button_group.addButton(checkbox)                  # <---
            self.tableWidget.setCellWidget(y, 5, checkbox)
        #checked_list = []
        
        #print(checked_list)
        sometable = self.table_to_list(self.tableWidget)
        for i in range(self.tableWidget.rowCount()):
            #print(self.tableWidget.rowCount())
            item = self.tableWidget.item(i, 3)
            if item.checkState():
                #checked_list.append([i,1])
                sometable[3][i] = True
            else:
                sometable[3][i] = False
            for j in range(4,6):
                item = self.tableWidget.cellWidget(i, j)
                if item.isChecked():
                    sometable[j][i] = True
                else:
                    sometable[j][i] = False
        proplen, tablen = len(headersMain), len(sometable[0])
        for i in range(tablen):
            for j in range(proplen):
                if sometable[0][i] == headersMain[j]:
                    sometable[0][i] = j
                    break
        print(sometable)
        self.currentfilter = sometable
            #self.tableWidget.setCellWidget(y, x, new self.label)
        #self.tableWidget.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        horizontalHeader = self.tableWidget.horizontalHeader()
        for i in range(len(headers)):
            horizontalHeader.setSectionResizeMode(
                i, QtWidgets.QHeaderView.ResizeToContents)
        # resize the first column to 100 pixels
        """
        for i in range(len(headers)):
            horizontalHeader.setSectionResizeMode(
                i, QtWidgets.QHeaderView.ResizeToContents)
        horizontalHeader = self.tableWidget_2.horizontalHeader()
        for i in range(len(self.headersMain)):
            horizontalHeader.setSectionResizeMode(
                i, QtWidgets.QHeaderView.ResizeToContents)
        horizontalHeader = self.tableWidget_3.horizontalHeader()
        for i in range(len(self.headersMain)):
            horizontalHeader.setSectionResizeMode(
                i, QtWidgets.QHeaderView.ResizeToContents)
        """
        #for y in range(row):
        #    for x in range(col):
        #        self.tableWidget.setCellWidget(y, x, self.tableWidget)
    def newText2(self, source, author, text):
        #print(text)
        
        newarr = [
            [0],
        ] * len(self.headersMain)
        
        #newarr[4] = [self.currentnewtext]
        out = self.processText(text)
        if out != "error":
            print(out)
            
            out[1] = str(author)
            print(out[1])
            outlen = len(out)
            for i in range(outlen):
                newarr[i+4] = [out[i]]
            sum2darray = lambda a, b:  [a[i]+b[i] for i in range(len(a))]
            self.currentmainarr = sum2darray(self.currentmainarr,newarr)
            self.updateTable2()
    def newText(self):
        self.currentnewtext = self.textEdit.toPlainText()
        print(self.currentnewtext)
        
        newarr = [
            [0],
        ] * len(self.headersMain)
        
        #newarr[4] = [self.currentnewtext]
        out = self.processText(self.currentnewtext)
        if out != "error":
            print(out)
            outlen = len(out)
            for i in range(outlen):
                newarr[i+4] = [out[i]]
            sum2darray = lambda a, b:  [a[i]+b[i] for i in range(len(a))]
            self.currentmainarr = sum2darray(self.currentmainarr,newarr)
            self.updateTable2()
    def initializeWidgets(self):
        self.setTable1()
        self.setTable2()
    def setupUIAdditions(self):
        self.pushButton.clicked.connect(lambda: self.filter2(self.currentfilter))
        self.pushButton_2.clicked.connect(lambda: self.newText())
        self.pushButton_3.clicked.connect(lambda: self.searchURL())
        self.initializeWidgets()
        
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(440, 50, 311, 192))
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(0)
        self.tableWidget.setRowCount(0)
        self.tableWidget_2 = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget_2.setGeometry(QtCore.QRect(20, 10, 361, 241))
        self.tableWidget_2.setObjectName("tableWidget_2")
        self.tableWidget_2.setColumnCount(0)
        self.tableWidget_2.setRowCount(0)
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(540, 250, 101, 31))
        self.pushButton.setObjectName("pushButton")
        self.tableWidget_3 = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget_3.setGeometry(QtCore.QRect(20, 280, 361, 241))
        self.tableWidget_3.setObjectName("tableWidget_3")
        self.tableWidget_3.setColumnCount(5)
        self.tableWidget_3.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(4, item)
        self.textEdit = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(430, 340, 291, 31))
        self.textEdit.setObjectName("textEdit")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(390, 350, 47, 13))
        self.label.setObjectName("label")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(530, 380, 101, 31))
        self.pushButton_2.setObjectName("pushButton_2")
        self.textEdit_2 = QtWidgets.QTextEdit(self.centralwidget)
        self.textEdit_2.setGeometry(QtCore.QRect(430, 430, 291, 31))
        self.textEdit_2.setObjectName("textEdit_2")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(390, 440, 47, 13))
        self.label_2.setObjectName("label_2")
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(QtCore.QRect(530, 470, 101, 31))
        self.pushButton_3.setObjectName("pushButton_3")
        MainWindow.setCentralWidget(self.centralwidget)
        
        self.setupUIAdditions()
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton.setText(_translate("MainWindow", "Filter"))
        item = self.tableWidget_3.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Toxic"))
        item = self.tableWidget_3.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Severe Toxic"))
        item = self.tableWidget_3.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Obscene"))
        item = self.tableWidget_3.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow", "Threat"))
        item = self.tableWidget_3.horizontalHeaderItem(4)
        item.setText(_translate("MainWindow", "Identity Hate"))
        self.label.setText(_translate("MainWindow", "Text"))
        self.pushButton_2.setText(_translate("MainWindow", "Analyze"))
        self.label_2.setText(_translate("MainWindow", "Link"))
        self.pushButton_3.setText(_translate("MainWindow", "Scrape"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
